# This worksheet is meant as a complement to “Computing the Chow variety of quadratic space curves”, by Peter Bürgisser, Kathlén Kohn, Pierre Lairez, and Bernd Sturmfels.
# 
# The package FGb, to compute efficiently Groebner basis, is available at
# http://www-polsys.lip6.fr/~jcf/FGb/FGb/index.html
with(FGb): with(LinearAlgebra):
# The computation of some of the Groebner bases require ~10 GB of RAM, so for convenienc, some of the results are preloaded.
read "GBs.mpl":


# [Section 1] Coordinates and quadrics in G(2,4)
# Stiefel coordinates: a point in G(2,4) is given as the column space of a 4x2 matrix.
stiefelMat := Matrix(4,2,(i,j)->a[i+10*j]);
stiefelVars := [op(indets(stiefelMat))];
# (Dual) Plucker coordinates: a point in G(2,4) is given by the 2x2 minors of the matrix of Stiefel coordinates.
pluckerCo := [seq(seq(p[i-1,j-1]=Determinant(stiefelMat[[i,j],1..2]), j=i+1..4), i=1..3)];
pluckerDual := { p[0,1] = p[2,3], p[0,2] = -p[1,3], p[0,3] = p[1,2], p[1,2] = p[0,3], p[1,3] = -p[0,2], p[2,3] = p[0,1] };
pluckerVars := convert(select(has,indets(pluckerCo),p),list);
# Plucker coordinates are bound by the Plucker relation
pluckerRel := p[0, 1]*p[2, 3]-p[0, 2]*p[1, 3]+p[0, 3]*p[1, 2];
# A generic 6x6 symmetric matrix. The change of basis c[5]=c[5]+c[12], c[9]=c[9]-c[12] makes c[12] disappear below.
sym6 := subs([c[5]=c[5]+c[12], c[9]=c[9]-c[12]], Matrix(6, 6, [c[0], c[1], c[2], c[3], c[4], c[5], c[1], c[6], c[7], c[8], c[9], c[10], c[2], c[7], c[11], c[12], c[13], c[14], c[3], c[8], c[12], c[15], c[16], c[17], c[4], c[9], c[13], c[16], c[18], c[19], c[5], c[10], c[14], c[17], c[19], c[20]]));
cvars := [seq(c[i], i=0..20)];
# The ideals we will compute do not depend on c[12], as explain in the article.
cvars0 := remove(`=`, cvars, c[12]);
# A generic quadratic form in the Plucker coordinates.
gQ := collect(Vector[row](pluckerVars).sym6.Vector(pluckerVars), pluckerVars, distributed);
# A quadratic form in the Plucker coordinates defines a quadric hypersurface of G(2,4). Two forms that differ by a multiple of the Plucker relation give the same quadric. Thus, the set of quadric of G(2,4) can be identified with the projectivization of the quotient of C^21 (the quadratic forms) by the Plucker relation (cf. the article).


# [Section 2] Ideal of coisotropic quadrics in G(2,4)
# Now, let us see the condition that gQ defines a coisotropic hypersurface.
# The quadric defined by gQ is coisotropic if there are t[0], t[1] and t[2], not all zero, such that the following vanishes:
coisoCondition := t[0]*(diff(gQ, p[0,1])*diff(gQ,p[2,3])-diff(gQ,p[0,2])*diff(gQ,p[1,3])+diff(gQ,p[0,3])*diff(gQ,p[1,2])) + t[1]*gQ + t[2]*pluckerRel:
# So here are the equations:
coisoConditionCoeffs := [coeffs(collect(coisoCondition, pluckerVars, 'distributed'), pluckerVars)];
# The t[i]'s are eliminated using linear algebra.
coisoConditionMat := Matrix(map(e -> [seq(coeff(e, t[i]), i=0..2)], coisoConditionCoeffs));
# The equations we are looking for are the 3x3 minors of the matrix above.
gensCoiso := convert(convert([seq(Determinant(coisoConditionMat[p,1..3]), p in combinat[choose]([seq(i, i in 1..21)],3))], set),list):
# The equations do not depend on c[12].
nops(select(has, gensCoiso, c[12]));
# And we compute a Groebner basis of the ideal generated by these equations. (Preloaded.)
# gbCoiso := fgb_gbasis(gensCoiso, 0, cvars, []):


# [Section 3] Ideal of the Chow forms of two lines
# We start with one line given by the Plucker coordinates q[i,j]
# The line given by the p[i,j] meets the other if and only if the following vanishes:
meetCondition := p[0,1]*q[2,3] - p[0,2]*q[1,3] + p[0,3]*q[1,2] + p[2,3]*q[0,1] - p[1,3]*q[0,2] + p[1,2]*q[0,3];
# Indeed, translated into Stiefel coordinates, this polynomial is just a determinant:
Matrix([stiefelMat, subs(a=b,stiefelMat)]);
normal(subs(pluckerCo, subs([p=q,a=b], pluckerCo), meetCondition) - Determinant(%));
# Therefore, the quadric gQ is the Chow form of a pair of skew lines if it equals the product of form meetCondition above, for some lines q[i,j] and s[i,j], modulo the Plucker relation.
Groebner[Reduce](gQ - meetCondition*subs(q=s, meetCondition), [pluckerRel], tdeg(op(pluckerVars)));
eqsChowLines := [coeffs(%, pluckerVars), subs(p=q, pluckerRel), subs(p=s, pluckerRel)];
# Again, the equations do not depend on c[12].
nops(select(has, eqsChowLines, c[12]));
# It only remains to eleminate the q's and the s's.
[op(indets(eqsChowLines) minus {op(cvars)})], cvars;
# WARNING : the computation below requires ~ 10GB of RAM.
# gbChowLines := fgb_gbasis_elim(eqsChowLines, 0, %, {"verb" = 3, "index" = 10^8}):


# [Section 4] Ideal of the Chow forms of plane conics
# Let us consider a plane conic in P^3, given by a linear form f1 and a quadratic form f2.
pX := stiefelMat.Vector([1,t]);
f1 := collect(add(u[i]*pX[i], i=1..4), t, normal);
f2 := collect(Transpose(pX).Matrix(4,4,(i,j) -> v[i+10*j], shape=symmetric).pX, t, normal);
# A line in P^3, given by Stiefel coordinates meets the conic if and only if the following resultant vanishes:
res := resultant(f1, f2, t):
# We can express this resultant as a quadratic form in the Plucker coordinates.
pluckerRes := fgb_gbasis_elim([res, seq(pluckerVars[i]-subs(pluckerCo,pluckerVars[i]), i=1..6)], 0, stiefelVars, [op(indets(res) minus {op(stiefelVars)}), op(pluckerVars)])[1];
# Therefore, the quadric gQ is the Chow form of a plane conic if it equals the form above, for some f1 and f2, modulo the Plucker relation.
Groebner[NormalForm](gQ - pluckerRes, [pluckerRel], tdeg(op(pluckerVars)));
eqsChowConic := [coeffs(%, pluckerVars)];
# It only remains to eleminate the u's and the v's.
# WARNING : the computation below requires ~ 10GB of RAM.
select(has, eqsChowConic, c[12]);
# gbChowConic := fgb_gbasis_elim(eqsChowConic, 0, [op(indets(eqsChowConic) minus {op(cvars)})], cvars0, {"verb" = 3, "index" = 10^8}):
# Consistency check
map(normal, subs(solve(eqsChowConic, cvars)[1], gbChowConic));


# [Section 5] Ideal of the Hurwitz forms of quadrics in P^3
# A line in P^3, given by Stiefel coordinates is tangent to the quadric defined by f2 if and only if the following discriminant vanishes:
disc := collect(discrim(f2, t), stiefelVars, 'distributed');
# This can be expressed in terms of the Plucker coordinates.
pluckerDisc := fgb_gbasis_elim([disc, seq(pluckerVars[i]-subs(pluckerCo,pluckerVars[i]), i=1..6)], 0, stiefelVars, [op(indets(disc) minus {op(stiefelVars)}), op(pluckerVars)])[1];
# As above, we look for the conditions that gQ equals pluckerDisc modulo the Plucker relation.
Groebner[NormalForm](gQ - pluckerDisc, [pluckerRel], tdeg(op(pluckerVars)));
eqsHurwitz := [coeffs(%, pluckerVars)];
# WARNING : the computation below requires some RAM.
# gbHurwitz := fgb_gbasis_elim(eqsHurwitz, 0, [op(indets(eqsHurwitz) minus {op(cvars)})], cvars0, {"verb" = 3, "index" = 10^8}):


# [Section 5bis] Ideal of the Hurwitz forms of quadrics in P^3 (alternative method)
# See B. Sturmfels: The Hurwitz form of a projective variety, Example 2.2, for more details about the method.
sym4 := Matrix(4, (i,j) -> d[i+10*j], shape = symmetric);
choose24 := combinat[choose]([1,2,3,4], 2);
extSym4 := Matrix(6, (i,j) -> Determinant(sym4[choose24[i], choose24[j]]));
gHurwitz := collect(Vector[row](pluckerVars).extSym4.Vector(pluckerVars), pluckerVars, distributed);
Groebner[Reduce](gQ - gHurwitz, [pluckerRel], tdeg(op(pluckerVars)));
eqsHurwitzAlt := [coeffs(%, pluckerVars)];
nops(select(has, eqsHurwitzAlt, c[12]));
# It only remains to eleminate the d's
# WARNING : the computation below requires some RAM.
# gbHurwitzAlt := fgb_gbasis_elim(eqsHurwitzAlt, 0, [op(indets(eqsHurwitzAlt) minus {op(cvars)})], cvars0, {"verb" = 3, "index" = 10^8}):
# evalb(gbHurwitz = gbHurwitzAlt);


# [Section 6] Ideal of Chow forms that are squares
Groebner[Reduce](gQ - add(e[i]*pluckerVars[i], i=1..6)^2, [pluckerRel], tdeg(op(pluckerVars)));
eqsSquare := [coeffs(%, pluckerVars)];
select(has, eqsSquare, c[12]);
[op(indets(eqsSquare) minus {op(cvars)})], cvars0;
# It only remains to eleminate the e's.
gbSquare := fgb_gbasis_elim(eqsSquare, 0, %, {"verb" = 3}):


# [Section 7] Some inclusions
map(Groebner[Reduce], gensCoiso, gbChowConic, tdeg(op(cvars0)));
map(Groebner[Reduce], gensCoiso, gbChowLines, tdeg(op(cvars0)));
map(Groebner[Reduce], gensCoiso, gbHurwitz, tdeg(op(cvars0)));
map(Groebner[Reduce], gensCoiso, gbSquare, tdeg(op(cvars0)));
# This is Proposition 2 in “Computing the Chow variety of quadratic space curves”
map(Groebner[Reduce], gbHurwitz, gbChowConic, tdeg(op(cvars0)));
# [Section 8] Primary decomposition of the coisotropic ideal
# We now check that the coisotropic ideal is the intersection of the ideals corresponding to Chow forms of conics, Chow form of skew lines and Hurwitz form of quadrics.
eqsInter := [1-u[1]-u[2]-u[3], seq(u[1]*p, p in gbSquare), seq(u[2]*p, p in gbHurwitz), seq(u[3]*p, p in gbChowLines)]:
# This computes Groebner basis of the intersection.
gbInter := fgb_gbasis_elim(eqsInter, 0, [u[1], u[2], u[3]], cvars0):
# This is Proposition 1 in “Computing the Chow variety of quadratic space curves”
evalb(gbInter = gbCoiso);


# [Section 9] Ideal of the Chow variety
# The Chow variety G(2,2,4) is formed by the Chow forms of all plane cubics and all pairs of skew lines.
eqsChowForm := [seq((1-t)*p, p in gbChowLines), seq(t*p, p in gbChowConic)]:
gbChowForm := fgb_gbasis_elim(eqsChowForm, 0, [t], cvars0): nops(%);


# [Section 10] The integrability ideal
# A few functions to deal with differential forms.
read "Df.mpl": with(Df[MM]):
# 
# Here, we deal with affine the following affine chart of the Grassmaniann.
affineCo := [a[11]=1,a[21]=0,a[12]=0,a[22]=1];
affineVars := remove(type, subs(affineCo, stiefelVars), integer);
pluckerToAffine := subs(affineCo, pluckerCo);

alg := map(v->d[v], convert(affineVars, set));
# Note that we use dual coordinates.
affgQ := subs(pluckerDual, pluckerToAffine, gQ);
affineMat := subs(affineCo, stiefelMat);
alphas := [seq(seq(add(diff(affgQ,affineMat[l+2,i])*d[affineMat[l+2,j]],l=1..2),j=1..2),i=1..2)];
# For the integrability condition to be satisfied by affgQ, the following differential forms should vanish on the quadric defined by affgQ:
[seq(seq(Mul(Mul(Diff(affgQ, alg), Diff(alphas[i],alg), alg),alphas[j],alg),j=1..nops(alphas)),i=1..nops(alphas))]:
# So we take the remainders modulo affgQ:
map(eq->normal(eq/convert(alg,`*`)), %):
Groebner[NormalForm](%, [affgQ], tdeg(op(affineVars))):
# And we obtain polynomials in the affineVars whose coefficients should be zero.
map(collect, %, affineVars, 'distributed'): map(coeffs, %, affineVars):
gensIntegrability_base := map(numer@normal, %):
# The integrability equations do not depend on c[12].
nops(select(has, gensIntegrability_base, c[12]));
# And we do the same for all the other charts. Equivalently, we permute the coordinates of C^4 and this induces a transformations of the c's that we apply to the equations above.
permutations := map[3](zip, `=`, [0,1,2,3], combinat[permute]([0,1,2,3]));
# Permutations of the coordinates of C^4 induces transformations of the Plucker coordinates:
subs([seq(seq(p[i,j]=-p[j,i], j=0..i), i=0..3)], map(p -> zip(`=`, pluckerVars, subs(p, pluckerVars)), permutations));
subs(c=d, map(subs, %, gQ)):
map( p->subs(d=c,solve([coeffs(gQ - p, pluckerVars)], cvars)[1]), %):
map(op, map(subs, %, gensIntegrability_base)):
gensIntegrability := [op(gbCoiso), op(convert(map(normal, %), set))]:
gbIntegrability := fgb_gbasis(gensIntegrability, 0, [], cvars0):
# Now we want to check Proposition 3 of “Computing ...”

eqsChowFormOrSquare := [seq((1-t)*p, p in gbChowForm), seq(t*p, p in gbSquare )]:
# We compute a Groebner basis for the triple intersection of P_ChowConic, P_ChowLines and P_Square.
gbChowFormOrSquare := fgb_gbasis_elim(eqsChowFormOrSquare, 0, [t], cvars0):
nops(gbChowFormOrSquare);
# The integrability ideal is contained in the triple intersection.
map(Groebner[Reduce], gbIntegrability, gbChowFormOrSquare, tdeg(op(cvars0)));
# We now compare the Hilbert series of both ideals.
fgb_hilbert(gbIntegrability, 0, cvars0, [], t): hilbIntegrability := %[1]/(1-t)^%[2];
fgb_hilbert(gbChowFormOrSquare, 0, cvars0, [], t): hilbChowFormOrSquare := %[1]/(1-t)^%[2];
# There is exactly one polynomial (modulo the ideal Integrability) which is in the ideal ChowFormOrSquare but not in Integrability and it is a cubic.
normal(hilbIntegrability - hilbChowFormOrSquare);
# Let us find this polynomial:
pol3 := (select(p -> degree(p) = 3, convert(gbChowFormOrSquare, set)) minus select(p -> degree(p) = 3, convert(gbIntegrability, set)))[1];
Groebner[Reduce](pol3, gbChowFormOrSquare, tdeg(op(cvars0)));
Groebner[Reduce](pol3, gbIntegrability, tdeg(op(cvars0)));
Groebner[Reduce](map(`*`, cvars0, pol3), gbIntegrability, tdeg(op(cvars0)));
# This concludes the proof of Proposition 3.


# [Annex] Save to file
# Save to file the Groebner bases for future use.
GBs := [gbCoiso, gbChowLines, gbChowConic, gbHurwitz, gbSquare, gbIntegrability]:
fd := fopen("GBs.mpl", WRITE):
fprintf(fd, "gbCoiso := %a:\n\ngbChowLines := %a:\n\ngbChowConic := %a:\n\ngbHurwitz := %a:\n\ngbSquare := %a:\n\ngbIntegrability := %a:\n\n", op(GBs));
fclose(fd):

# Save the Groebner bases for use in Magma.
fd := fopen("GBs.magma", WRITE):
fprintf(fd, "ICoiso := Ideal( %a );\n\nIChowLines := Ideal( %a );\n\nIChowConic := Ideal( %a );\n\nIHurwitz := Ideal( %a );\n\nISquare := Ideal( %a );\n\nJ := Ideal( %a );\n\n",
op(subs([seq(c[i]=c||i, i=0..20)], GBs)));
fclose(fd):


